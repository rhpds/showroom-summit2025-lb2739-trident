# Module 2: Install and configure Trident on the DR OpenShift cluster

This task is generally done by the OpenShift administrator.

NetApp Trident can be installed in various ways:

* Using a installer binary for very customized environments 
* Using an operator manifest
* Using a Helm Chart

Starting with NetApp Trident 25.02, this CSI driver is also available as a certified operator in the OperatorHub catalog. +
You will use that method in this lab.

[#operatorinstall]
== Find the NetApp Trident Operator

* Connect to the RedHat OpenShift GUI on the secondary cluster
* Locate the *OperatorHub* sub-menu in the *Operators* category
* Filter on *trident*

OPERATOR IMAGE

== Install the NetApp Trident Operator

* Click on the operator to install
* Review the details and press the `Install` button

== Verification with the command line

* Connect to the jumphost
* Log in OpenShift
* Retrieve and verify the Trident version.

=== Authenticate `oc` to the cluster

The bastion provided with the RHDP workshop has the `aws` and `rosa` command line tools already installed and logged in.  The `oc` command is installed, but not authenticated.

To authenticate `oc` use the API URL, username, and password provided by the RHDP lab deployment.

[source,bash,role=execute,subs="attributes"]
----
oc login -u {rosa2_openshift_admin_user} -p {rosa2_openshift_admin_password} {rosa2_openshift_api_url}
----

[#tridentinstalled]
=== Check the Trident version
[.lines_space]
[.console-input]
[source,bash,role=execute,subs="attributes"]
----
oc get tver -n trident
----
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME      VERSION
trident   25.02.1
----

=== Verify that all Trident pods are running

[.lines_space]
[.console-input]
[source,bash,role=execute,subs="attributes"]
----
oc get pods -n trident
----
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                                  READY   STATUS    RESTARTS   AGE
trident-controller-599494bc5f-qnssz   6/6     Running   0          34s
trident-node-linux-4s6jg              2/2     Running   0          34s
trident-node-linux-9jx9g              2/2     Running   0          34s
trident-node-linux-d7b7x              2/2     Running   0          34s
trident-node-linux-jrv8v              2/2     Running   0          34s
trident-node-linux-lpcj4              2/2     Running   0          34s
trident-node-linux-qm8nz              2/2     Running   0          34s
trident-node-linux-sc2tn              2/2     Running   0          34s
----

Installing the _tridentctl_ binary on this environment could be useful, especially for troubleshooting.
[.lines_space]
[.console-input]
[source,bash,role=execute,subs="attributes"]
----
wget https://github.com/NetApp/trident/releases/download/v25.02.1/trident-installer-25.02.1.tar.gz
tar -xf trident-installer-25.02.1.tar.gz
sudo cp trident-installer/tridentctl /usr/local/bin/tridentctl
----
Verify the installation by viewing the Trident version of the installed operator.
[.lines_space]
[.console-input]
[source,bash,role=execute,subs="attributes"]
----
tridentctl -n trident version
----
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
+----------------+----------------+
| SERVER VERSION | CLIENT VERSION |
+----------------+----------------+
| 25.02.1        | 25.02.1        |
+----------------+----------------+
----

[#tridentconfiguration]
== Configure Trident

A *backend* defines the relationship between Trident and a storage system. It tells Trident how to communicate with that storage system and how Trident should provision volumes from it.
These backends are linked to a *secret* which contains the credentials of the storage system.

=== Create a secret to store the SVM username and password in the ROSA cluster

This can be done vie the OpenShift Console or the GUI. +
Let's use the cli:

[source,bash,role=execute,subs="attributes"]
----
cat << EOF | oc apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: dr-backend-fsxn-secret
  namespace: trident
type: Opaque
stringData:
  username: fsxadmin
  password: Rosa12345
EOF
----

Verify the secret has been added to the ROSA cluster.
[.lines_space]
[.console-input]
[source,bash,role=execute,subs="attributes"]
----
oc get secrets -n trident dr-backend-fsxn-secret
----
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                        TYPE                                  DATA   AGE
backend-fsxn-secret         Opaque                                2      24h
----

=== Create the Trident Backend for NFS

Before creating the backend, you need to retrieve the management IP of the Storage Virtual Machine setup in AWS FSxN. +
Let's assign it to a variable.

[source,bash,role=execute,subs="attributes"]
----
export SVMIP=$(aws fsx describe-storage-virtual-machines | jq -r '.StorageVirtualMachines[].Endpoints.Management.IpAddresses[]') && echo $SVMIP
----

Run the following commands to create the Trident backend in the ROSA cluster.

[source,bash,role=execute,subs="attributes"]
----
cat << EOF | oc apply -f -
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: dr-backend-fsxn-nfs
  namespace: trident
spec:
  version: 1
  backendName: dr-fsxn-nfs
  storageDriverName: ontap-nas
  managementLIF: $SVMIP
  nasType: nfs
  autoExportCIDRs:
  - 10.10.0.0/16
  autoExportPolicy: true
  storagePrefix: dr
  defaults:
    snapshotDir: 'true'
    nameTemplate: "{{ .config.StoragePrefix }}_{{ .volume.Namespace }}_{{ .volume.RequestName }}"
  credentials:
    name: dr-backend-fsxn-secret
EOF
----

Some explanations about the content of that manifest:

* `autoExportPolicy`: lets Trident dynamically manage the NFS export policies in AWS FSXN by setting one rule per ROSA node
* `autoExportCIDRs`: list of CIDRs to filter ROSA's nodes IP addresses against
* `storagePrefix`: all volumes created by Trident will start with those letters
* `nameTemplate`: all volumes created by Trident will follow that naming convention (instead of using the PV UUID)

Verify the backend configuration.

[source,bash,role=execute,subs="attributes"]
----
oc get tridentbackendconfigs backend-fsxn-nfs -n trident
----
[.lines_space]
[.console-output]
[source,bash]
----
NAME               BACKEND NAME   BACKEND UUID                           PHASE   STATUS
backend-fsxn-nfs   fsxn-nfs       1f490bf3-492c-4ef7-899e-9e7d8711c82f   Bound   Success
----

=== Create the Trident Backend for iSCSI

The IP from the SVM has already been assigned to a variable in the previous paragraph. +
You can reuse the same one here, as the same SVM will be used for both protocols

[source,bash,role=execute,subs="attributes"]
----
cat << EOF | oc apply -f -
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: dr-backend-fsxn-iscsi
  namespace: trident
spec:
  version: 1
  backendName: dr-fsxn-iscsi
  storageDriverName: ontap-san
  managementLIF: 10.0.63.80
  sanType: iscsi
  credentials:
    name: dr-backend-fsxn-secret
EOF
----

Verify the backend configuration.
[source,bash,role=execute,subs="attributes"]
----
oc get tridentbackendconfigs dr-backend-fsxn-iscsi -n trident
----
[.lines_space]
[.console-output]
[source,bash]
----
NAME                    BACKEND NAME        BACKEND UUID                           PHASE   STATUS
dr-backend-fsxn-iscsi   dr-fsxn-iscsi       1f490bf3-492c-4ef7-899e-9e7d8711c82g   Bound   Success
----

[#storageclasses]
== Storage Classes

The very last step is about creating storage classes that will use Trident backends. +
A storage class is necessary to instruct Trident how to provision volumes.  

[NOTE]
====
ReadWriteMany (RWX) is required for *_Live Migration_* of your VMs. 
This access mode is supported with all protocols proposed by Trident (File and Block).  
====

However, configuring a RWX workload with a block protocol such as iSCSI requires two things:

* the storage class must not specifcy any filesystem
* the PVC must explicitly mention `volumeMode: Block`

You are going to create 3 storage classes:

* `storage-class-nfs`: File workdloads, supports all ROSA access modes
* `storage-class-iscsi-fs`: Block workloads, does not support RWX access mode
* `storage-class-iscsi-blk`: Block workloads, supports all access modes, including RWX

=== Create a NFS Storage Class

Run the following command to create the first storage class in the ROSA cluster. +
This will be done via the lab console.

[source,bash,role=execute,subs="attributes"]
----
cat << EOF | oc apply -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: storage-class-nfs
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-nas"
  nasType: "nfs"
allowVolumeExpansion: true
EOF
----

Verify the storage class creation.

[source,bash,role=execute,subs="attributes"]
----
oc get sc storage-class-nfs
----
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                      PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
storage-class-nfs         csi.trident.netapp.io   Delete          Immediate              true                   10s
----

=== Create an iSCSI Storage Class with a file system

This will be done with the OpenShift Console. +
Once connected to the GUI, navigate to the `Storage` menu and `StorageClasses` sub-menu. +

You can easily create a new one by pressing on the `Create StorageClass` button at the top right of the screen. +
Once on this page, switch to edit mode by clicking on the `Edit YAML` link, and paste the following and press on Create

[.lines_space]
[.console-output]
[source,yaml]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: storage-class-iscsi-fs
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  sanType: "iscsi"
  fsType: "ext4"
mountOptions:
   - discard
allowVolumeExpansion: true
----

image::OCP_Console_Storage_Classes_Create.png[storageclasses]

Verify the storage class creation.
[source,bash,role=execute,subs="attributes"]
----
oc get sc storage-class-iscsi-fs
----
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                      PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
storage-class-iscsi-fs    csi.trident.netapp.io   Delete          Immediate              true                   10s
----

=== Create an iSCSI Storage Class for RWX workloads

Use the same method as the previous storage class, via the GUI. +
Copy & paste the following:
[source,bash,role=execute,subs="attributes"]
----
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: storage-class-iscsi-blk
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  sanType: "iscsi"
allowVolumeExpansion: true
----

Verify the storage class creation.
[source,bash,role=execute,subs="attributes"]
----
oc get sc storage-class-iscsi-fs
----
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                      PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
storage-class-iscsi-fs    csi.trident.netapp.io   Delete          Immediate              true                   10s
----

This is also visible in the OpenShift Console:

image::OCP_Console_Storage_Classes.png[storageclasses]