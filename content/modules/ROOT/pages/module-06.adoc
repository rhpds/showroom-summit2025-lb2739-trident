# Module 6: Disaster Recovery Plan for your VM

== Virtual Machine customization

The Virtual Machine should be up&running by now. +
Check its status from the GUI:

===> IMAGE

You can now connect to this VM and write some content in the _home_ folder. +

NOTE
====
Make sure 
====

===> IMAGE

== DR Setup

Time to protect this very critical workloads!  +
We are going to use the CLI to perform that operation. +

Make sure you are connected on the PROD cluster:
[.lines_space]
[.console-input]
[source,bash]
----
oc config use-context $(oc config get-contexts | grep -E default.*api-prod | cut -c 11- | awk '{print $1}')
----

Setting the Disaster Recovery Plan is done in a few steps:

* Configure the "storage peering" between the source and target environments (_already done for you during the lab creation_)
* Create a Trident Protect application (for the whole namespace in this exercise)
* Create an Application snapshot (_and optionally a schedule_)
* Retrieve the application ID
* Setup the Trident Protect AMR (_Application Mirror Relationship_)

NOTE: Creating the AMR can be done with GitOps methodologies to automatically protect your application

=== Create a Trident Protect application for the *my-vm* namespace
Make sure you are logged into the production cluster. +

[.lines_space]
[.console-input]
[source,bash]
----
tridentctl-protect create app my-vm --namespaces my-vm -n my-vm
----
Check that the application is present:
[.lines_space]
[.console-input]
[source,bash]
----
tridentctl-protect get app -n my-vm
----
[.console-output]
[source,bash]
----
+-----------+------------+-------+-----+
|   NAME    | NAMESPACES | STATE | AGE |
+-----------+------------+-------+-----+
|   my-vm   |   my-vm    | Ready | 26s |
+-----------+------------+-------+-----+
----

=== Create a Trident Protect snapshot of the *my-vm* namespace

[.lines_space]
[.console-input]
[source,bash]
----
tridentctl-protect create snapshot vmsnap1 --app my-vm --appvault lab-vault -n my-vm
----
Check that the snapshot is done:
[.lines_space]
[.console-input]
[source,bash]
----
tridentctl-protect get snap -n my-vm
----
[.console-output]
[source,bash]
----
+-----------+--------------+-----------+-----+-------+
|   NAME    |    APP REF   |   STATE   | AGE | ERROR |
+-----------+--------------+-----------+-----+-------+
|  vmsnap1  |     my-vm    | Completed | 11s |       |
+-----------+--------------+-----------+-----+-------+
----

=== Retrieve the Trident Protect application ID

Place that ID in a variable, and check the result.

[.lines_space]
[.console-input]
[source,bash]
----
SRCAPPID=$(tridentctl-protect get app my-vm -n my-vm -o json | jq -r .metadata.uid)
echo $SRCAPPID
----

=== Setup the mirroring relationship

Switch context to the DR cluster. +
Once there, you can create a new namespace which will host the mirror of the app.
[.lines_space]
[.console-input]
[source,bash]
----
oc config use-context $(oc config get-contexts | grep -E default.*api-dr | cut -c 11- | awk '{print $1}')

oc create ns vmdr

cat << EOF | oc apply -f -
apiVersion: protect.trident.netapp.io/v1
kind: AppMirrorRelationship
metadata:
  name: vmamr1
  namespace: vmdr
spec:
  desiredState: Established
  destinationAppVaultRef: lab-vault
  namespaceMapping:
  - destination: vmdr
    source: my-vm
  recurrenceRule: |-
    DTSTART:20240901T000200Z
    RRULE:FREQ=MINUTELY;INTERVAL=5
  sourceAppVaultRef: lab-vault
  sourceApplicationName: my-vm
  sourceApplicationUID: $SRCAPPID
  storageClassName: storage-class-iscsi
EOF
----

[IMPORTANT]
====
As you need to specifcy the target storage class when creating an _AMR_, make sure it fits the same protocol and services as the source one.
You cannot mirror from iSCSI to NFS for instance (but you can backup from iSCSI and restore to NFS)
====

Let's check the status of this new object on the DR cluster:
[.lines_space]
[.console-input]
[source,bash]
----
tridentctlprotect get amr -n vmdr
----
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+--------------+-----+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |     STATE    | AGE | ERROR |
+----------+--------------+-----------------+---------------+--------------+-----+-------+
|  vmamr1  |  lab-vault   |    lab-vault    | Established   | Establishing | 41s |       |
+----------+--------------+-----------------+---------------+--------------+-----+-------+
----
It will take a couple of minutes for the mirroring to be setup, or `Established`.
[.lines_space]
[.console-input]
[source,bash]
----
tridentctlprotect get amr -n vmdr
----
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |    STATE    |  AGE  | ERROR |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|  vmamr1  |  lab-vault   |    lab-vault    | Established   | Established |  1m30 |       |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
----

== Failover your application

Failover your application is pretty straight forward. +
You just need to _patch_ the AMR on the DR cluster.

[.lines_space]
[.console-input]
[source,bash]
----
oc patch amr vmamr1 -n vmdr --type=merge -p '{"spec":{"desiredState":"Promoted"}}'
----
Fairly quickly, you should get to the following result:
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |    STATE    |  AGE  | ERROR |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|  vmamr1  |  lab-vault   |    lab-vault    |   Promoted    |   Promoted  |  20s  |       |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
----

Let's check the content of our namespace:
[.lines_space]
[.console-input]
[source,bash]
----
oc get -n vmdr vm,pvc
----
[.console-output]
[source,bash]
----
TODOOOO
----

== Check the result

Connect to the OpenShift DR Console and navigate to the Virtual Machines menu.
