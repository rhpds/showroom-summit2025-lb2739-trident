# Module 6: Disaster Recovery Plan for your VM

== Virtual Machine customization

The Virtual Machine should be up&running by now. +
Check its status from the GUI:

===> IMAGE

You can now connect to this VM and write some content in the _home_ folder. +

NOTE
====
Make sure 
====

===> IMAGE

== DR Setup

Time to protect this very critical workloads!  +
We are going to use the CLI to perform that operation. +

Make sure you are connected on the PROD cluster:
[.lines_space]
[.console-input]
[source,bash]
----
oc config use-context $(oc config get-contexts | grep -E default.*api-prod | cut -c 11- | awk '{print $1}')
----

Setting the Disaster Recovery Plan is done in a few steps:

* Configure the "storage peering" between the source and target environments (_already done for you during the lab creation_)
* Create a Trident Protect application (for the whole namespace in this exercise)
* Create an Application snapshot (_and optionally a schedule_)
* Retrieve the application ID
* Setup the Trident Protect AMR (_Application Mirror Relationship_)

NOTE: Creating the AMR can be done with GitOps methodologies to automatically protect your application

=== Create a Trident Protect application for the *my-vm* namespace
Make sure you are logged into the production cluster. +

[.lines_space]
[.console-input]
[source,bash]
----
tridentctl-protect create app my-vm --namespaces my-vm -n my-vm
----
Check that the application is present:
[.lines_space]
[.console-input]
[source,bash]
----
tridentctl-protect get app -n my-vm
----
[.console-output]
[source,bash]
----
+-----------+------------+-------+-----+
|   NAME    | NAMESPACES | STATE | AGE |
+-----------+------------+-------+-----+
|   my-vm   |   my-vm    | Ready | 26s |
+-----------+------------+-------+-----+
----

=== Create a Trident Protect snapshot of the *my-vm* namespace

[.lines_space]
[.console-input]
[source,bash]
----
tridentctl protect create snapshot vmsnap1 --app my-vm --appvault lab-vault -n my-vm
----
Check that the snapshot is done:
[.lines_space]
[.console-input]
[source,bash]
----
tridentctl protect get snap -n my-vm
----
[.console-output]
[source,bash]
----
+-----------+--------------+-----------+-----+-------+
|   NAME    |    APP REF   |   STATE   | AGE | ERROR |
+-----------+--------------+-----------+-----+-------+
|  vmsnap1  |     my-vm    | Completed | 11s |       |
+-----------+--------------+-----------+-----+-------+
----

=== Retrieve the Trident Protect application ID

Place that ID in a variable, and check the result.

[.lines_space]
[.console-input]
[source,bash]
----
SRCAPPID=$(tridentctl-protect get app my-vm -n my-vm -o json | jq -r .metadata.uid)
echo $SRCAPPID
----

=== Setup the mirroring relationship

Switch context to the DR cluster. +
Once there, you can create a new namespace which will host the mirror of the app.
[.lines_space]
[.console-input]
[source,bash]
----
oc config use-context $(oc config get-contexts | grep -E default.*api-dr | cut -c 11- | awk '{print $1}')

oc create ns vmdr

cat << EOF | oc apply -f -
apiVersion: protect.trident.netapp.io/v1
kind: AppMirrorRelationship
metadata:
  name: vmamr1
  namespace: vmdr
spec:
  desiredState: Established
  destinationAppVaultRef: lab-vault
  namespaceMapping:
  - destination: vmdr
    source: my-vm
  recurrenceRule: |-
    DTSTART:20240901T000200Z
    RRULE:FREQ=MINUTELY;INTERVAL=5
  sourceAppVaultRef: lab-vault
  sourceApplicationName: my-vm
  sourceApplicationUID: $SRCAPPID
  storageClassName: storage-class-nfs
EOF
----
Let's check the status of this new object on the DR cluster:
[.lines_space]
[.console-input]
[source,bash]
----
tridentctlprotect get amr -n vmdr
----
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+--------------+-----+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |     STATE    | AGE | ERROR |
+----------+--------------+-----------------+---------------+--------------+-----+-------+
|  vmamr1  |  lab-vault   |    lab-vault    | Established   | Establishing | 41s |       |
+----------+--------------+-----------------+---------------+--------------+-----+-------+
----
It will take a couple of minutes for the mirroring to be setup, or `Established`.
[.lines_space]
[.console-input]
[source,bash]
----
tridentctlprotect get amr -n vmdr
----
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |    STATE    |  AGE  | ERROR |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|  vmamr1  |  lab-vault   |    lab-vault    | Established   | Established |  1m30 |       |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
----

== Failover your application

Failover your application is pretty straight forward. +
You just need to _patch_ the AMR on the DR cluster.

[.lines_space]
[.console-input]
[source,bash]
----
oc patch amr vmamr1 -n vmdr --type=merge -p '{"spec":{"desiredState":"Promoted"}}'
----
Fairly quickly, you should get to the following result:
[.console-output]
[source,bash]
----
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|   NAME   |  SOURCE APP  | DESTINATION APP | DESIRED STATE |    STATE    |  AGE  | ERROR |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
|  vmamr1  |  lab-vault   |    lab-vault    |   Promoted    |   Promoted  |  20s  |       |
+----------+--------------+-----------------+---------------+-------------+-------+-------+
----

Let's check the content of our namespace:
[.lines_space]
[.console-input]
[source,bash]
----
oc get -n vmdr vm,pvc
----
[.console-output]
[source,bash]
----
TODOOOO
----

== Check the result

Connect to the OpenShift DR Console and navigate to the Virtual Machines menu.
